# -*- coding: utf-8 -*-
import pandas as pd
import json
import random
from flask import Flask, render_template, jsonify, request, session
from collections import defaultdict

app = Flask(__name__)
app.secret_key = "chave-secreta-concursoia-2024"

# ---
# --- FONTE DE DADOS PRINCIPAL (PANDAS) ---
# ---
try:
    # Carrega o banco de dados de questões a partir do CSV
    df_questoes = pd.read_csv('questoes.csv', sep=';', quotechar='"')
    # Preenche valores NaN (vazios) com strings vazias para evitar erros
    df_questoes = df_questoes.fillna('')
    print(f"INFO: 'questoes.csv' carregado com sucesso. Total: {len(df_questoes)} questões.")
except Exception as e:
    print(f"ERRO CRÍTICO: Não foi possível ler 'questoes.csv'. Erro: {e}")
    df_questoes = pd.DataFrame() # Cria um dataframe vazio
# --- FIM DA FONTE DE DADOS ---


# --- Rota Principal ---
@app.route('/')
def index():
    return render_template('index.html')

# ---
# --- API (Backend) para o JavaScript ---
# ---

# CORRIGIDO: Esta função agora formata os dados como o script.js espera
@app.route('/api/areas')
def get_areas():
    try:
        if df_questoes.empty:
            return jsonify({"success": False, "error": "Banco de questões não carregado"}), 500
        
        # O script.js (Frontend) espera objetos com 'nome_area' e 'total_questoes'.
        contagem_areas = df_questoes['disciplina'].value_counts()
        
        areas_formatado = []
        for area_nome, total in contagem_areas.items():
            if pd.notna(area_nome) and area_nome != '':
                areas_formatado.append({
                    "nome_area": area_nome,
                    "total_questoes": int(total) # Garante que é um número
                })
        
        print(f"INFO: /api/areas - Encontradas {len(areas_formatado)} áreas com contagem.")
        # O script.js espera um objeto com uma chave 'areas'
        return jsonify({"success": True, "areas": areas_formatado})
        
    except Exception as e:
        print(f"ERRO em /api/areas: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

# CORRIGIDO: Esta função agora existe e corrige o Erro 404
@app.route('/api/bancas')
def get_bancas():
    try:
        # O script.js espera um objeto com uma chave 'bancas'
        # Enviamos dados falsos porque o CSV não tem esta coluna
        print("INFO: /api/bancas - Retornando dados falsos (Banca Padrão).")
        bancas_falsas = [{"banca": "(Banca Padrão)", "total_questoes": len(df_questoes)}]
        return jsonify({"success": True, "bancas": bancas_falsas}) 
    except Exception as e:
        print(f"ERRO em /api/bancas: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

# CORRIGIDO: Esta função agora existe e corrige o Erro 404
@app.route('/api/dashboard/estatisticas-areas')
def get_estatisticas_areas():
    try:
        if df_questoes.empty:
            return jsonify({"success": False, "error": "Banco de questões não carregado"}), 500

        # Esta é uma simulação. O script.js espera um formato complexo.
        # Por enquanto, vamos enviar a contagem de disciplinas para corrigir o Erro 404
        stats = df_questoes['disciplina'].value_counts().to_dict()
        
        # O script.js espera um objeto com uma chave 'stats_gerais'
        stats_falsas = {
            "total_simulados_feitos": 0,
            "media_geral_percentual": 0,
            "total_acertos_geral": 0,
            "melhor_desempenho": None,
            "stats_por_disciplina": stats
        }
        
        print("INFO: /api/dashboard - Estatísticas geradas (simplificadas).")
        return jsonify({"success": True, "stats_gerais": stats_falsas})
    except Exception as e:
        print(f"ERRO em /api/dashboard: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

# ---
# --- API DO SIMULADO (Corrigida para usar PANDAS) ---
# ---

# CORRIGIDO: Esta função agora usa PANDAS e não falha com a banca
@app.route('/api/simulado/iniciar', methods=['POST'])
def iniciar_simulado():
    try:
        data = request.json
        areas_selecionadas = data.get('areas', [])
        banca_selecionada = data.get('banca')
        quantidade_str = data.get('quantidade', '10')

        if not areas_selecionadas:
            return jsonify({"success": False, "error": "Nenhuma área selecionada."}), 400

        # 1. Filtra o DataFrame 'df_questoes' pelas disciplinas (áreas)
        questoes_filtradas = df_questoes[df_questoes['disciplina'].isin(areas_selecionadas)]

        if questoes_filtradas.empty:
            return jsonify({"success": False, "error": "Nenhuma questão encontrada para as áreas selecionadas."}), 404

        # 2. Seleciona a quantidade
        total_encontrado = len(questoes_filtradas)
        quantidade = int(quantidade_str)
        if quantidade > total_encontrado:
            quantidade = total_encontrado
        
        # 3. Seleciona as questões aleatoriamente
        questoes_selecionadas_df = questoes_filtradas.sample(n=quantidade)
        
        # 4. Converte para o formato JSON e armazena IDs na sessão
        questoes_prontas = []
        ids_na_sessao = []
        
        for index, row in questoes_selecionadas_df.iterrows():
            # O script.js espera um objeto 'alternativas' aninhado
            alternativas_obj = {
                'a': row.get('alternativa_a'),
                'b': row.get('alternativa_b'),
                'c': row.get('alternativa_c'),
                'd': row.get('alternativa_d'),
                'e': row.get('alternativa_e')
            }
            
            questao_formatada = {
                "id": int(index), # Usando o índice do DataFrame como ID
                "disciplina": row.get('disciplina'),
                "materia": row.get('materia'),
                "dificuldade": row.get('dificuldade'),
                "enunciado": row.get('enunciado'),
                "alternativas": alternativas_obj, # <--- CORRIGIDO
                "resposta_correta": row.get('resposta_correta'),
                "justificativa": row.get('justificativa'),
                "dica": row.get('dica'),
                "formula": row.get('formula')
            }
            questoes_prontas.append(questao_formatada)
            ids_na_sessao.append(int(index))

        # Armazena na sessão
        session['simulado_ids'] = ids_na_sessao
        session['simulado_respostas'] = {} 
        session['indice_atual'] = 0
        
        primeira_questao = questoes_prontas[0]
        
        return jsonify({
            "success": True,
            "total_questoes": len(questoes_prontas),
            "indice_atual": 0,
            "questao": primeira_questao,
            "resposta_anterior": None
        })

    except Exception as e:
        print(f"ERRO 500 em /api/simulado/iniciar: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/simulado/questao/<int:indice>')
def get_questao(indice):
    questoes_ids = session.get('simulado_ids')
    if not questoes_ids:
        return jsonify({"success": False, "error": "Simulado não encontrado na sessão."}), 404
        
    total_questoes = len(questoes_ids)
    
    if 0 <= indice < total_questoes:
        session['indice_atual'] = indice
        questao_id = questoes_ids[indice]
        try:
            # Busca a questão no DataFrame
            row = df_questoes.loc[questao_id]
            
            alternativas_obj = {
                'a': row.get('alternativa_a'),
                'b': row.get('alternativa_b'),
                'c': row.get('alternativa_c'),
                'd': row.get('alternativa_d'),
                'e': row.get('alternativa_e')
            }
            
            questao_atual = {
                "id": int(questao_id),
                "disciplina": row.get('disciplina'),
                "materia": row.get('materia'),
                "dificuldade": row.get('dificuldade'),
                "enunciado": row.get('enunciado'),
                "alternativas": alternativas_obj, # <--- CORRIGIDO
                "resposta_correta": row.get('resposta_correta'),
                "justificativa": row.get('justificativa'),
                "dica": row.get('dica'),
                "formula": row.get('formula')
            }
            
            resposta_anterior = session.get('simulado_respostas', {}).get(str(questao_atual['id']))
            
            return jsonify({
                "success": True,
                "total_questoes": total_questoes,
                "indice_atual": indice,
                "questao": questao_atual,
                "resposta_anterior": resposta_anterior
            })
        except Exception as e:
             return jsonify({"success": False, "error": f"Erro ao buscar questão: {e}"}), 500
    else:
        return jsonify({"success": False, "error": "Índice da questão fora dos limites."}), 404

@app.route('/api/simulado/responder', methods=['POST'])
def responder_questao():
    data = request.json
    questao_id = str(data.get('questao_id'))
    alternativa_escolhida = data.get('alternativa', '').lower()
    
    respostas = session.get('simulado_respostas', {})

    if questao_id in respostas:
        return jsonify({"success": False, "error": "Esta questão já foi respondida."}), 400

    try:
        # Busca a questão no DataFrame
        row = df_questoes.loc[int(questao_id)]
             
        resposta_certa = row.get('resposta_correta', '').lower()
        acertou = (alternativa_escolhida == resposta_certa)

        respostas[questao_id] = {
            "alternativa_escolhida": alternativa_escolhida,
            "acertou": acertou
        }
        session['simulado_respostas'] = respostas
        
        return jsonify({
            "success": True,
            "acertou": acertou,
            "resposta_correta": resposta_certa.upper(),
            "justificativa": row.get('justificativa', 'Sem justificativa detalhada.')
        })
    except Exception as e:
        return jsonify({"success": False, "error": f"Erro ao verificar resposta: {e}"}), 500

@app.route('/api/simulado/finalizar', methods=['POST'])
def finalizar_simulado():
    questoes_ids = session.get('simulado_ids')
    respostas = session.get('simulado_respostas', {})
    
    if not questoes_ids:
        return jsonify({"success": False, "error": "Nenhum simulado ativo para finalizar."}), 404

    total_questoes = len(questoes_ids)
    total_acertos = 0

    try:
        # Busca as questões respondidas no DataFrame
        questoes_respondidas_df = df_questoes.loc[questoes_ids]

        for questao_id in questoes_ids:
            resposta = respostas.get(str(questao_id))
            if resposta and resposta['acertou']:
                total_acertos += 1
        
        percentual_acerto = round((total_acertos / total_questoes) * 100, 2) if total_questoes > 0 else 0
        
    except Exception as e:
        print(f"Erro ao salvar resultado: {e}")
        return jsonify({"success": False, "error": f"Erro ao salvar dados: {e}"}), 500

    session.pop('simulado_ids', None)
    session.pop('simulado_respostas', None)
    session.pop('indice_atual', None)

    return jsonify({
        "success": True,
        "relatorio": {
            "total_questoes": total_questoes,
            "total_acertos": total_acertos,
            "percentual_acerto": percentual_acerto,
            "nota_final": percentual_acerto
        }
    })

# ---
# --- API DA REDAÇÃO (Mantida como estava) ---
# ---
@app.route('/api/redacao/temas')
def get_temas_redacao():
    temas = [
        {"id": 1, "titulo": "Os desafios da educação pública brasileira no século XXI"},
        {"id": 2, "titulo": "Impactos da inteligência artificial no mercado de trabalho"},
        {"id": 3, "titulo": "Crise hídrica e gestão sustentável dos recursos naturais"},
        {"id": 4, "titulo": "Violência urbana e políticas de segurança pública"},
        {"id": 5, "titulo": "Desafios do sistema de saúde pública no Brasil"},
        {"id": 6, "titulo": "A importância da preservação da Amazônia para o equilíbrio climático"},
        {"id": 7, "titulo": "Os efeitos das fake news na democracia brasileira"},
        {"id": 8, "titulo": "Mobilidade urbana e qualidade de vida nas grandes cidades"},
        {"id": 9, "titulo": "Desigualdade social e seus impactos no acesso à educação"},
        {"id": 10, "titulo": "Tecnologia e privacidade: os limites da exposição digital"}
        # ... (temas restantes omitidos por brevidade) ...
    ]
    return jsonify({"success": True, "temas": temas})

@app.route('/api/redacao/corrigir-gemini', methods=['POST'])
def corrigir_gemini():
    data = request.json
    tema = data.get('tema')
    texto = data.get('texto')
    
    if not tema or not texto:
        return jsonify({"success": False, "error": "Tema e texto são obrigatórios."}), 400

    try:
        nota_simulada = random.randint(60, 95) 
        correcao_data = {
            "nota_final": nota_simulada,
            "analise_competencias": [
                {"competencia": "Competência 1: Domínio da norma culta", "nota": round(nota_simulada * 0.18), "comentario": "Bom domínio da norma padrão, com poucos desvios gramaticais."},
                {"competencia": "Competência 2: Compreensão do tema e estrutura", "nota": round(nota_simulada * 0.20), "comentario": "Tema compreendido adequadamente com estrutura dissertativa clara."},
                {"competencia": "Competência 3: Argumentação e repertório", "nota": round(nota_simulada * 0.19), "comentario": "Argumentos consistentes, poderia usar mais repertório sociocultural."},
                {"competencia": "Competência 4: Coesão e coerência", "nota": round(nota_simulada * 0.20), "comentario": "Texto coeso com boa progressão argumentativa."},
                {"competencia": "Competência 5: Proposta de intervenção", "nota": round(nota_simulada * 0.23), "comentario": "Proposta concreta e detalhada, respeitando os direitos humanos."}
            ],
            "pontos_fortes": ["Estrutura organizada", "Argumentação clara", "Proposta de intervenção completa"],
            "pontos_fracos": ["Poderia usar mais exemplos concretos", "Repertório sociocultural limitado"],
            "sugestoes_melhoria": ["Ampliar o repertório de citações", "Desenvolver mais os exemplos"],
            "dicas_concursos": ["Mantenha a estrutura dissertativa", "Use conectivos variados", "Revise a concordância verbal"]
        }
        return jsonify({"success": True, "correcao": correcao_data})
        
    except Exception as e:
        return jsonify({"success": False, "error": f"Erro ao processar correção: {e}"}), 500

# --- FIM DO ARQUIVO ---